----
### 1. 有哪些HTTP方法？
----

* post: 常用来提交表单，修改数据等。
* get: 获取数据资源.
* head: 获取http头部信息。
* options：获取当前URL支持的方法，cors中就会用到。
* put ：更新资源
* delete：删除资源

----
### 2. POST和GET的区别？
----

* GET的在浏览器中可以回退，POST需要重新再次提交数据。
* GET通过URL传递参数，POST通过body传递参数。
* GET 参数有限制长度，POST没有。
* GET没有POST安全，因为参数直接暴露在了URL上。
* GET能被浏览器缓存和收藏，POST不行，当然想要缓存可以手动设置，但收藏就不行了。

----
### 3. HTTP状态码有哪些，分别代表什么？
----

* 1xx:请求已接受，继续处理。
* 2xx:成功。
* 3xx:重定向。
* 4xx: 客户端错误。
* 5xx: 服务端错误。

常见的具体请求：
* 200：正确获取数据。
* 204: 请求成功，但返回没有主体。
* 301：永久重定向
* 302：临时重定向
* 307：这个POST的重定向的时候会遇到，就是301、302原本需要遵守的规定，除GET、HEAD方法外，其他的请求方法必须等客户确认才能跳转，现在307表示不遵守了。
* 400： bad request 请求报文语法错误
* 401： 认证错误
* 403: 请求资源被服务器拒绝。
* 404： 服务器没有找到对应资源。
* 500： 服务器发生错误
* 501： 服务器不支持这个功能
* 503： 服务器在维护或者请求超负载了。


----
### 4. 说说你对TCP三次握手和四次挥手的理解？
----
##### TCP连接的建立（三次握手）
首先要认识几个标志位和序号：
>SYN:表示建立连接
>ACK:表示确认序号有效
>FIN:表示关闭连接
>RST:表示连接重置
>PSH:表示有 DATA数据传输
>
发送报文时，带上相应的标志位，就代表相应的意思
>1.seq序号，占32位，发起方发送数据时进行标记。
>2.ack序号，确认序号，占32位。
>
例如:
* SYN=1,代表建立连接
* SYN=1,和ACK=1，就代表建立连接和确认序号有效。
* ACK=1，代表确认序号有效


![三次握手](https://upload-images.jianshu.io/upload_images/11948845-f7df13ddc74b4508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>第一次握手：客户端A向服务器B发送请求报文
>
###### *请求报文是这样的*
1.标志符：SYN=1，代表建立连接
2.随机初始化的一个序号：比如seq=x.
客户端A进入（SYN-SEND）同步已发送状态。
>第二次握手：服务器B收到后，如果同意连接，那么服务器B就会向客户端A发送一个确认报文。
>
###### *确认报文是这样的*
1.标志符:ACK=1，表示对刚刚的SYN包的确认，SYN=1，表示B与A建立连接。
2.随机初始化一个序号：比如seq=y.
3.确认序号ack：ack是刚刚客户端A发送过来的序号+1,也就是x+1。
服务器B进入SYN-RCVD(同步收到)状态
>第三次握手：客户端A收到服务器B的确认报文后，再向服务器B发送一个确认报文。
>
###### *这个确认报文是这样的：*
1.标志符:ACK=1，表示对刚刚的SYN包的确认。
2.seq是上个请求的序号+1,也就是x+1
3.确认序号ack：ack是刚刚客户端B发送过来的序号+1，也就是y+1.
客户端和服务器进入ESTABLISHED（TCP连接成功）状态。
#####*单纯看标志符就是这样一个过程：*
1. (A) –> [SYN] –> (B)
2. (B) -> [SYN/ACK] -> (A)
3. (A) –> [ACK] –> (B)
* *看序号的话就是这样的*
方向     seq      ack
A->B    2000  0
B->A    3000  2001
A->B    2001  3001
* A随机初始化了一个序号seq=2000
* B随机初始化了一个序号seq=3000
* A在接着上一个请求继续下去，seq=20001。

服务器B收到后确认seq值和ACK，说明连接建立成功。

##### TCP连接的断开（四次挥手）
![四次挥手](https://upload-images.jianshu.io/upload_images/11948845-18297ce3c4dededa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
*假设客户端A想要断开连接*
----
第一次挥手：
>客户端发送一个 FIN 标志位为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
>
*发送完毕后，客户端进入 FIN_WAIT_1 状态。*
第二次挥手：
>服务器B确认客户端A发送的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，**但还没有准备好关闭连接**。
>
*发送完毕后，服务器端进入 CLOSE_WAIT 状态.
客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。*
第三次挥手：
>服务器端准备好关闭连接时，向客户端发送FIN 为1的结束连接请求。
>
*发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。*
第四次挥手：
>* 客户端:接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态。等待可能出现的要求重传的 ACK 包。
>* 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
>* 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。
>
##### *形象点说就像这样*
* A说:"我说完了。"  A进去FIN-WAIT-1状态。
* B说:"我知道你说完了，但我还没说完啊,我还没准备好，让你等会。"
于是呢A进入了FIN-WAIT-2状态，B进去了CLOSE-WAIT状态

* B说："我讲完了，我也不说了"于是B进去了LAST-ACK状态。
* A说："好了，我知道你不说了"于是A进去了TIME-WAIT状态。B进入了CLOSED状态
* 最后A在等了一会，发现B没有理他，于是认为B不说话了，自己也不说了。A进去了CLOSED状态。



----
### 4. 为什么连接的时候是三次握手，关闭的时候却是四次挥手？
----


> 不同地方就在于：
* 关闭连接时，是分别发送ACK包和FIN包的。
* 建立连接时，SYN包和ACK包可以一起发送。

这样的原因是因为：关闭连接时，可能客户端A还在发送报文，只能告诉客户端，我已经收到了。直到客户端A发送完报文时，服务器B才可以发送FIN报文。

----
### 6. 什么是HTTPS和HTTP的区别？
----

* HTTPS和HTTP的区别主要在于多了一层TLS层。
* HTTP是明文传输，hTTPS传输过程是加密的较安全。
* 因为加密过程中会消耗些性能，所以HTTP响应速度会比较比HTTPS快。
* 使用的端口不一样，一个是80，一个是443。


----
### 7. 说说HTTP的发展过程和特点？
----
* http/0.9: 传输简单的html
* http/1.0: html无法满足了，通过头部来确定各种资源文件。
* http/1.1: 新增了持久化连接来满足当页面引用较多外部资源文件的时候。
* http/2.0: 通过二进制分帧的方式来提高传输效率，简称**多路复用**，避免了http/1.1中，多个请求共用一个tcp连接，但某个连接阻塞的问题，同时不再受限于http连接数。


----
### 8. 什么是同源策略，跨域？
----
* 同源： 同域名，协议，端口
* 跨域：处于安全所做的限制：不同源的资源无法相互访问。

> 解决跨域的问题的办法：


----
### 9. 常见的跨域解决办法有哪些？
----

* 1. JSONP
利用<script>标签没有跨域的特点来实现，然后通过callback的形式来获取数据。
* 2. CORS
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

----
### 11. TCP和UDP的区别？
----

* 1. tcp有链接，udp无连接
* 2. tcp面向字节流，udp面向报文
* 3. tcp可靠，udp不可靠
* 4. tcp头部开销比较大，udp开销小
----
### 12. ajax的工作原理？
----

----
### 13. 什么是XSS攻击/sql注入，csrf攻击以及如何防范？
----

* xss:跨站脚本攻击，将web页面插入恶意的js脚本。
解决办法：后端对前端提交的所有敏感字符都要进行转义，前端页面在引用数据的时候也要进行转义。
* sql注入：在表单，url等地方写入sql语句，达到获取数据库中数据的一种手段。
解决：过滤特殊字符，检查用户的输入类型和格式。
* csrf：跨站请求伪造，冒充用户进行一些非法操作，已达到某种目的。
解决：
* 同源检测：阻止不清楚的外域的访问。
* csrf Token，生成一个攻击者无法冒充的token。这样服务器就知道此操作是不是用户本人的操作了。
----
### 14. 什么是CDN?
----
* CDN：内容分发网络，主要是对资源进行缓存，已达到减轻服务器压力，同时加快访问速度的作用。用户的访问的资源会在从最近的CDN节点开始查找，若为找到则返回，没找到则请求原网站。

----
### 15. 防抖节流的实现?
----
* 防抖： 一定时间内多次触发，只会以最后的触发事件为准。

```
function debounce(func,timeout){
    let timer;
    return funciton(){
        clearTimeout(timer);
        timer = setTimeout(func.bind(this),timeout)
    }
}
```
* 节流：控制发生的频率
```
function throttle(f,timeout){
    let timer;
    return function(...args){
        if(timer)return;
        timer = setTimout(()=>{
         f(...args)   
        },timeout)
    }
}
```